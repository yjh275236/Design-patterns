# 设计模式详解

## 目录

- [引言](#引言)
- [创建型模式 (Creational Patterns)](#创建型模式-creational-patterns)
  - [1. 单例模式 (Singleton)](#1-单例模式-singleton)
  - [2. 工厂方法模式 (Factory Method)](#2-工厂方法模式-factory-method)
  - [3. 抽象工厂模式 (Abstract Factory)](#3-抽象工厂模式-abstract-factory)
  - [4. 建造者模式 (Builder)](#4-建造者模式-builder)
  - [5. 原型模式 (Prototype)](#5-原型模式-prototype)
- [结构型模式 (Structural Patterns)](#结构型模式-structural-patterns)
  - [6. 适配器模式 (Adapter)](#6-适配器模式-adapter)
  - [7. 桥接模式 (Bridge)](#7-桥接模式-bridge)
  - [8. 组合模式 (Composite)](#8-组合模式-composite)
  - [9. 装饰模式 (Decorator)](#9-装饰模式-decorator)
  - [10. 外观模式 (Facade)](#10-外观模式-facade)
  - [11. 享元模式 (Flyweight)](#11-享元模式-flyweight)
  - [12. 代理模式 (Proxy)](#12-代理模式-proxy)
- [行为型模式 (Behavioral Patterns)](#行为型模式-behavioral-patterns)
  - [13. 责任链模式 (Chain of Responsibility)](#13-责任链模式-chain-of-responsibility)
  - [14. 命令模式 (Command)](#14-命令模式-command)
  - [15. 解释器模式 (Interpreter)](#15-解释器模式-interpreter)
  - [16. 迭代器模式 (Iterator)](#16-迭代器模式-iterator)
  - [17. 中介者模式 (Mediator)](#17-中介者模式-mediator)
  - [18. 备忘录模式 (Memento)](#18-备忘录模式-memento)
  - [19. 观察者模式 (Observer)](#19-观察者模式-observer)
  - [20. 状态模式 (State)](#20-状态模式-state)
  - [21. 策略模式 (Strategy)](#21-策略模式-strategy)
  - [22. 模板方法模式 (Template Method)](#22-模板方法模式-template-method)
  - [23. 访问者模式 (Visitor)](#23-访问者模式-visitor)

---

## 引言

设计模式是软件开发中常见问题的可重用解决方案。它们提供了经过验证的代码组织方式，可以帮助开发者编写更易维护、可扩展和健壮的代码。

本项目的设计模式实现基于 **Swift** 语言，涵盖了 **GoF (Gang of Four)** 提出的 23 种经典设计模式，分为三大类别：

- **创建型模式** (5种)：关注对象的创建机制
- **结构型模式** (7种)：关注类和对象的组合
- **行为型模式** (11种)：关注对象之间的通信和职责分配

---

## 创建型模式 (Creational Patterns)

创建型模式提供了在创建对象时的灵活性和复用性，它们封装了对象创建的逻辑，使代码独立于具体类。

### 1. 单例模式 (Singleton)

**定义**：确保一个类只有一个实例，并提供全局访问点。

**目的**：
- 控制实例数量，节省系统资源
- 提供全局访问点
- 确保实例的唯一性

**适用场景**：
- 需要共享资源时（如数据库连接、日志管理器）
- 需要一个唯一的对象来协调系统操作
- 需要控制访问数量

**实现要点**：
- 私有构造函数防止外部创建实例
- 静态成员变量保存唯一实例
- 提供静态方法获取实例

**示例代码位置**：`Design patterns/Creational/SingletonPattern.swift`

**关键代码**：
```swift
class DatabaseManager {
    static let shared = DatabaseManager()
    private init() { }
}
```

---

### 2. 工厂方法模式 (Factory Method)

**定义**：定义一个创建对象的接口，让子类决定实例化哪一个类。

**目的**：
- 将对象的创建与使用分离
- 增加新的产品类型时，只需添加新的工厂类
- 避免客户端代码与具体类耦合

**适用场景**：
- 无法预知需要创建哪种具体对象
- 需要统一管理对象创建逻辑
- 需要支持多种产品类型

**实现要点**：
- 定义抽象工厂接口
- 具体工厂类实现接口
- 产品类层次结构

**示例代码位置**：`Design patterns/Creational/FactoryMethodPattern.swift`

---

### 3. 抽象工厂模式 (Abstract Factory)

**定义**：提供一个接口，用于创建相关或依赖对象的家族。

**目的**：
- 创建一组相关的对象
- 确保创建的对象相互兼容
- 隔离具体类的实例化

**适用场景**：
- 需要创建多个相关对象族
- 需要保证对象之间的兼容性
- 产品族需要切换时

**实现要点**：
- 抽象工厂定义创建多个产品的接口
- 具体工厂实现创建具体产品的逻辑
- 产品系列之间有依赖关系

**示例代码位置**：`Design patterns/Creational/AbstractFactoryPattern.swift`

**关键代码**：
```swift
protocol UIFactory {
    func createButton() -> Button
    func createCheckbox() -> Checkbox
}
```

---

### 4. 建造者模式 (Builder)

**定义**：将一个复杂对象的构建与其表示分离，使同样的构建过程可以创建不同的表示。

**目的**：
- 逐步构建复杂对象
- 代码复用性高
- 灵活配置对象属性

**适用场景**：
- 对象有多个可选参数
- 需要构建复杂对象
- 构建过程需要独立于组成部分

**实现要点**：
- 建造者接口定义构建步骤
- 具体建造者实现构建逻辑
- 指导者控制构建顺序

**示例代码位置**：`Design patterns/Creational/BuilderPattern.swift`

---

### 5. 原型模式 (Prototype)

**定义**：通过复制现有实例来创建新实例。

**目的**：
- 避免重复创建对象的开销
- 动态指定运行时创建的对象类型
- 隐藏对象创建的复杂性

**适用场景**：
- 对象创建成本较高时
- 需要动态创建相似对象
- 需要避免使用类的层次结构

**实现要点**：
- 实现 Cloneable 接口
- 提供克隆方法
- 支持深拷贝和浅拷贝

**示例代码位置**：`Design patterns/Creational/PrototypePattern.swift`

---

## 结构型模式 (Structural Patterns)

结构型模式关注如何组合类和对象以形成更大的结构，同时保持结构的灵活性和高效性。

### 6. 适配器模式 (Adapter)

**定义**：将一个类的接口转换成客户希望的另一个接口。

**目的**：
- 让不兼容的接口可以协同工作
- 复用现有代码
- 解耦客户端和适配者

**适用场景**：
- 需要使用现有类但其接口不匹配
- 需要创建一个可复用的类
- 需要集成第三方库

**实现要点**：
- 目标接口（客户端期望的接口）
- 适配者类（需要适配的类）
- 适配器类（实现转换逻辑）

**示例代码位置**：`Design patterns/Structural/AdapterPattern.swift`

**关键代码**：
```swift
class MediaAdapter: MediaPlayer {
    private var advancedPlayer: AdvancedMediaPlayer?
    // 将 AdvancedMediaPlayer 适配为 MediaPlayer
}
```

---

### 7. 桥接模式 (Bridge)

**定义**：将抽象部分与实现部分分离，使它们可以独立变化。

**目的**：
- 解耦抽象和实现
- 提高可扩展性
- 隐藏实现细节

**适用场景**：
- 需要在运行时切换实现
- 抽象和实现需要独立变化
- 需要避免永久绑定

**实现要点**：
- 抽象类持有实现类的引用
- 实现接口定义操作
- 具体实现类实现接口

**示例代码位置**：`Design patterns/Structural/BridgePattern.swift`

---

### 8. 组合模式 (Composite)

**定义**：将对象组合成树形结构以表示部分-整体的层次结构。

**目的**：
- 统一处理单个对象和组合对象
- 简化客户端代码
- 灵活添加新类型的组件

**适用场景**：
- 需要表示对象的部分-整体层次
- 希望用户忽略单个对象和组合对象的区别
- 树形结构需要统一操作

**实现要点**：
- 组件接口定义统一操作
- 叶子节点实现具体操作
- 组合节点包含子组件

**示例代码位置**：`Design patterns/Structural/CompositePattern.swift`

---

### 9. 装饰模式 (Decorator)

**定义**：动态地给一个对象添加一些额外的职责。

**目的**：
- 在不修改原类的情况下扩展功能
- 组合多个功能
- 运行时动态添加功能

**适用场景**：
- 需要动态、透明地添加功能
- 不适合使用继承扩展功能
- 需要独立地添加多个功能

**实现要点**：
- 组件接口定义基本操作
- 具体组件实现基本功能
- 装饰器持有组件引用并扩展功能

**示例代码位置**：`Design patterns/Structural/DecoratorPattern.swift`

---

### 10. 外观模式 (Facade)

**定义**：为子系统中的一组接口提供一个统一的接口。

**目的**：
- 简化复杂子系统的使用
- 降低客户端与子系统的耦合
- 提供一个清晰的入口点

**适用场景**：
- 需要简化复杂系统接口
- 需要分层构建系统
- 需要与遗留系统集成

**实现要点**：
- 外观类封装子系统
- 提供简化的统一接口
- 处理子系统之间的协调

**示例代码位置**：`Design patterns/Structural/FacadePattern.swift`

---

### 11. 享元模式 (Flyweight)

**定义**：运用共享技术有效地支持大量细粒度的对象。

**目的**：
- 减少对象数量
- 降低内存占用
- 提高性能

**适用场景**：
- 需要创建大量相似对象
- 对象的大部分状态可以外部化
- 对象状态可以在需要时计算

**实现要点**：
- 享元接口定义操作
- 具体享元实现共享状态
- 享元工厂管理享元对象池

**示例代码位置**：`Design patterns/Structural/FlyweightPattern.swift`

---

### 12. 代理模式 (Proxy)

**定义**：为其他对象提供一种代理以控制对这个对象的访问。

**目的**：
- 控制对原始对象的访问
- 添加额外的功能
- 延迟加载对象

**适用场景**：
- 需要控制对象访问
- 需要延迟加载
- 需要添加额外功能（如缓存、日志）

**实现要点**：
- 主题接口定义操作
- 真实主题实现具体操作
- 代理类控制访问并可能添加功能

**示例代码位置**：`Design patterns/Structural/ProxyPattern.swift`

---

## 行为型模式 (Behavioral Patterns)

行为型模式关注对象之间的职责分配和算法，描述对象如何协作完成任务。

### 13. 责任链模式 (Chain of Responsibility)

**定义**：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。

**目的**：
- 降低发送者和接收者的耦合
- 动态指定处理请求的对象
- 灵活添加新的处理者

**适用场景**：
- 多个对象可能处理同一个请求
- 需要动态指定处理对象
- 需要避免请求发送者和接收者的耦合

**实现要点**：
- 抽象处理者定义处理接口
- 具体处理者实现处理逻辑
- 形成处理链

**示例代码位置**：`Design patterns/Behavioral/ChainOfResponsibilityPattern.swift`

---

### 14. 命令模式 (Command)

**定义**：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。

**目的**：
- 将请求封装为对象
- 支持撤销和重做操作
- 解耦请求的发起者和接收者

**适用场景**：
- 需要参数化对象
- 需要支持撤销操作
- 需要记录和日志请求

**实现要点**：
- 命令接口定义执行方法
- 具体命令实现请求封装
- 调用者执行命令
- 接收者执行实际操作

**示例代码位置**：`Design patterns/Behavioral/CommandPattern.swift`

---

### 15. 解释器模式 (Interpreter)

**定义**：给定一个语言，定义它的文法的一种表示，并定义一个解释器。

**目的**：
- 解释和执行特定语言的句子
- 易于实现简单的语言
- 易于修改和扩展语法

**适用场景**：
- 需要解释简单语言
- 语言的文法规则相对固定
- 需要频繁解释执行

**实现要点**：
- 抽象表达式定义解释方法
- 终结符表达式实现原子操作
- 非终结符表达式组合多个表达式

**示例代码位置**：`Design patterns/Behavioral/InterpreterPattern.swift`

---

### 16. 迭代器模式 (Iterator)

**定义**：提供一种方法顺序访问一个聚合对象中各个元素。

**目的**：
- 统一遍历集合的方式
- 隐藏集合的内部结构
- 支持多种遍历方式

**适用场景**：
- 需要遍历集合对象
- 需要支持多种遍历方式
- 需要隐藏集合的内部结构

**实现要点**：
- 迭代器接口定义遍历方法
- 具体迭代器实现遍历逻辑
- 聚合接口定义创建迭代器方法

**示例代码位置**：`Design patterns/Behavioral/IteratorPattern.swift`

---

### 17. 中介者模式 (Mediator)

**定义**：用一个中介对象来封装一系列的对象交互。

**目的**：
- 降低对象之间的直接耦合
- 简化对象间的交互
- 集中控制交互逻辑

**适用场景**：
- 对象之间存在复杂的交互
- 需要避免对象之间的紧耦合
- 需要集中管理交互逻辑

**实现要点**：
- 中介者接口定义交互方法
- 具体中介者实现交互逻辑
- 同事类与中介者通信

**示例代码位置**：`Design patterns/Behavioral/MediatorPattern.swift`

---

### 18. 备忘录模式 (Memento)

**定义**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

**目的**：
- 保存对象状态以便恢复
- 不破坏对象的封装性
- 支持撤销操作

**适用场景**：
- 需要保存对象状态快照
- 需要支持撤销操作
- 不希望暴露对象内部结构

**实现要点**：
- 备忘录保存对象状态
- 原发器创建和恢复备忘录
- 管理者保存备忘录

**示例代码位置**：`Design patterns/Behavioral/MementoPattern.swift`

---

### 19. 观察者模式 (Observer)

**定义**：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知。

**目的**：
- 解耦观察者和被观察者
- 支持广播通信
- 动态添加或删除观察者

**适用场景**：
- 需要通知多个对象状态变化
- 需要解耦对象间的依赖
- 需要实现事件处理系统

**实现要点**：
- 主题接口定义注册和通知方法
- 具体主题维护观察者列表
- 观察者接口定义更新方法
- 具体观察者实现更新逻辑

**示例代码位置**：`Design patterns/Behavioral/ObserverPattern.swift`

**关键代码**：
```swift
protocol Subject {
    func registerObserver(_ observer: Observer)
    func removeObserver(_ observer: Observer)
    func notifyObservers()
}
```

---

### 20. 状态模式 (State)

**定义**：允许一个对象在其内部状态改变时改变它的行为。

**目的**：
- 将状态转换逻辑封装
- 简化条件判断
- 易于添加新状态

**适用场景**：
- 对象行为依赖于状态
- 状态转换逻辑复杂
- 需要避免大量条件判断

**实现要点**：
- 状态接口定义状态行为
- 具体状态实现状态行为
- 上下文维护当前状态

**示例代码位置**：`Design patterns/Behavioral/StatePattern.swift`

---

### 21. 策略模式 (Strategy)

**定义**：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。

**目的**：
- 将算法封装为独立对象
- 运行时切换算法
- 避免使用条件语句

**适用场景**：
- 有多种算法可以替换
- 需要在运行时选择算法
- 需要避免使用多重条件判断

**实现要点**：
- 策略接口定义算法方法
- 具体策略实现不同算法
- 上下文使用策略对象

**示例代码位置**：`Design patterns/Behavioral/StrategyPattern.swift`

---

### 22. 模板方法模式 (Template Method)

**定义**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

**目的**：
- 定义算法框架
- 子类实现具体步骤
- 代码复用

**适用场景**：
- 有多个类有相似的算法
- 需要固定算法框架
- 需要子类实现特定步骤

**实现要点**：
- 抽象类定义模板方法
- 模板方法调用抽象方法
- 具体子类实现抽象方法

**示例代码位置**：`Design patterns/Behavioral/TemplateMethodPattern.swift`

---

### 23. 访问者模式 (Visitor)

**定义**：表示一个作用于某对象结构中的各元素的操作。

**目的**：
- 在不改变元素类的前提下定义新操作
- 将操作与元素类分离
- 易于添加新操作

**适用场景**：
- 对象结构稳定但需要频繁添加操作
- 需要分离数据结构与操作
- 需要对不同类型对象执行不同操作

**实现要点**：
- 访问者接口定义访问方法
- 具体访问者实现操作逻辑
- 元素接口定义接受访问者方法
- 具体元素实现接受方法

**示例代码位置**：`Design patterns/Behavioral/VisitorPattern.swift`

---

## 总结

### 模式分类对比

| 类型 | 数量 | 主要关注点 |
|------|------|-----------|
| 创建型 | 5 | 对象的创建机制 |
| 结构型 | 7 | 类和对象的组合 |
| 行为型 | 11 | 对象间的通信和职责 |

### 设计原则

设计模式遵循以下面向对象设计原则：

1. **单一职责原则**：一个类应该只有一个引起它变化的原因
2. **开闭原则**：对扩展开放，对修改关闭
3. **里氏替换原则**：子类可以替换父类
4. **依赖倒置原则**：依赖抽象而不是具体实现
5. **接口隔离原则**：使用多个专门的接口，而不是单一的总接口
6. **迪米特法则**：只与直接的朋友通信

### 学习建议

1. **理解意图**：理解每个模式要解决的特定问题
2. **识别场景**：学会识别哪些场景适合使用哪种模式
3. **实际应用**：在实际项目中应用，加深理解
4. **避免过度设计**：不是所有情况都需要使用设计模式

### 参考资料

- **《设计模式：可复用面向对象软件的基础》** - GoF (Gang of Four)
- **项目代码示例**：查看各模式对应的 Swift 实现文件
- **Demo 视图控制器**：运行项目查看各模式的交互式演示

---

*本文档基于 Swift 语言实现的设计模式项目编写*

