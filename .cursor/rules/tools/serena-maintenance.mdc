---
alwaysApply: false
---

# Serena Memories 维护指南

本规则用于指导 AI 如何构建、更新和维护 Serena MCP 的 memory 文件。**仅在用户明确请求时使用此规则**。

## 使用场景

用户可以通过以下方式触发此规则：

```
@serena-maintenance 从头构建项目 memories
@serena-maintenance 更新 tech_stack.md，我添加了新库
@serena-maintenance 审计现有 memories 的质量
@serena-maintenance 精简 memories，删除冗余内容
@serena-maintenance 检查 memories 是否过时
```

## 智能使用模式

**推荐**: 用户只需引用 `@serena-maintenance`，AI 自动判断操作

### 自动评估流程

1. **检查现状**
   - 调用 `mcp_serena_list_memories` 
   - 统计文件数量和大小
   - 分析用户描述（如果有）

2. **智能决策**
   - 无 memories → 执行"构建"
   - 数量过多（> 5）或文件过大（> 600 行）→ 执行"审计"  
   - 用户提到具体变更 → 执行"更新"
   - 状态良好 → 提供"报告"

3. **执行反馈**
   - 告知执行的操作
   - 提供结果摘要

**用户无需明确指定操作类型！**

---

## Memory 文件结构规范

### 推荐的文件数量

根据项目规模选择合适的文件数量：

**小型项目**（< 50 个源文件）:
- **1-2 个文件**
- `project_overview.md` （必须）
- 根据需要选择 1 个推荐文件

**中型项目**（50-200 个源文件）:
- **2-4 个文件**（推荐）
- `project_overview.md` （必须）
- 从推荐文件中选择 2-3 个

**大型项目**（> 200 个源文件）:
- **3-5 个文件**（上限）
- 核心文件 + 按业务模块拆分

**重要原则**:
- ⚠️ 文件数量不超过 5 个（避免碎片化）
- ⚠️ 单个文件不超过 500 行
- ⚠️ 优先合并相关内容，而非拆分

### 标准文件清单

#### 1. project_overview.md（必须）

**用途**: 项目概览，优先级最高，新对话时首先读取

**推荐大小**: 100-200 行

**标准模板**:
```markdown
# 项目概览

## 项目基本信息
- **项目名称**: [项目名称]
- **Bundle ID**: [Bundle ID]
- **项目目的**: [简要描述项目用途和目标用户]
- **最低支持版本**: iOS XX.0
- **开发语言**: Swift
- **当前版本**: [版本号]

## 技术栈概览
- **开发语言**: Swift
- **UI 框架**: UIKit / SwiftUI
- **架构模式**: MVC / MVVM / VIPER
- **依赖管理**: CocoaPods / SPM / Carthage
- **核心第三方库**: 
  - Alamofire - 网络请求
  - Kingfisher - 图片加载
  - SnapKit - 自动布局
  （列出 5-10 个最重要的库）

## 目录结构
```
ProjectName/
├── AppDelegate.swift
├── Models/              # 数据模型
├── Views/               # UI 组件
├── Controllers/         # 视图控制器
├── Services/            # 业务逻辑
├── Utilities/           # 工具类
└── Resources/           # 资源文件
```

## 核心架构

### 基类说明
- **BaseViewController**: 所有 VC 的基类，处理通用导航栏配置
- **BaseViewModel**: MVVM 架构的 ViewModel 基类
- **BaseService**: 服务层基类

### 全局配置
- **AppConfig**: 存储 API 域名、Bundle ID 等配置
- **UserManager**: 用户状态管理

### 数据存储
- **本地存储**: UserDefaults / CoreData / Realm
- **缓存策略**: 内存缓存 + 磁盘缓存
- **敏感数据**: Keychain

## 开发环境

### 构建和运行
1. 安装依赖: `pod install` / `swift package resolve`
2. 打开工作空间: `ProjectName.xcworkspace`
3. 选择目标设备运行

### 必要配置
- Firebase 配置文件
- API 密钥配置
- 第三方 SDK 初始化

## 关键约定
- 类名前缀: [如 MyApp]
- 网络请求基类: [如 BaseRequest]
- 响应模型解析: [如使用 Codable]
```

---

#### 2. tech_stack.md（推荐）

**用途**: 详细记录技术栈和第三方库的使用

**推荐大小**: 200-400 行

**标准模板**:
```markdown
# 技术栈详情

## 第三方库列表

### Alamofire - 网络请求库

**用途**: HTTP 网络请求

**官方文档**: https://github.com/Alamofire/Alamofire

**项目中的使用**:
```swift
import Alamofire

class NetworkManager {
    static let shared = NetworkManager()
    
    func request<T: Codable>(
        _ endpoint: String,
        method: HTTPMethod = .get,
        parameters: Parameters? = nil
    ) async throws -> T {
        let response = try await AF.request(
            endpoint,
            method: method,
            parameters: parameters
        ).serializingDecodable(T.self).value
        
        return response
    }
}
```

**注意事项**:
- 使用单例模式管理网络请求
- 统一处理错误和响应
- 配置请求拦截器

---

### Kingfisher - 图片加载

**用途**: 异步图片下载和缓存

**官方文档**: https://github.com/onevcat/Kingfisher

**项目中的使用**:
```swift
import Kingfisher

imageView.kf.setImage(
    with: URL(string: imageURL),
    placeholder: UIImage(named: "placeholder"),
    options: [
        .transition(.fade(0.3)),
        .cacheOriginalImage
    ]
)
```

**配置**:
```swift
// AppDelegate 中配置
let cache = ImageCache.default
cache.memoryStorage.config.totalCostLimit = 100 * 1024 * 1024 // 100 MB
cache.diskStorage.config.sizeLimit = 500 * 1024 * 1024 // 500 MB
```

---

### SnapKit - 自动布局

**用途**: 声明式自动布局 DSL

**官方文档**: https://github.com/SnapKit/SnapKit

**项目中的使用**:
```swift
import SnapKit

private func setupUI() {
    view.addSubview(titleLabel)
    view.addSubview(submitButton)
    
    titleLabel.snp.makeConstraints { make in
        make.top.equalTo(view.safeAreaLayoutGuide).offset(20)
        make.left.right.equalToSuperview().inset(16)
    }
    
    submitButton.snp.makeConstraints { make in
        make.centerX.equalToSuperview()
        make.bottom.equalTo(view.safeAreaLayoutGuide).offset(-30)
        make.width.equalTo(200)
        make.height.equalTo(44)
    }
}
```

---

## Firebase 集成

### Firebase Analytics
- **用途**: 用户行为分析
- **事件追踪**: 登录、购买、页面浏览等
- **配置**: GoogleService-Info.plist

### Firebase Crashlytics
- **用途**: 崩溃报告
- **注意**: 不要上传敏感信息到崩溃日志

### Firebase Cloud Messaging
- **用途**: 推送通知
- **配置步骤**: 
  1. 配置 APNs 证书
  2. 在 AppDelegate 注册推送
  3. 实现 UNUserNotificationCenterDelegate

## 依赖管理

### CocoaPods
**Podfile 示例**:
```ruby
platform :ios, '14.0'
use_frameworks!

target 'ProjectName' do
  pod 'Alamofire', '~> 5.8'
  pod 'Kingfisher', '~> 7.10'
  pod 'SnapKit', '~> 5.7'
  pod 'Firebase/Analytics'
  pod 'Firebase/Crashlytics'
end
```

**常用命令**:
```bash
pod install           # 安装依赖
pod update            # 更新所有依赖
pod update [PodName]  # 更新特定依赖
pod outdated          # 查看过期依赖
```

### Swift Package Manager
**常用操作**:
- File → Add Package Dependencies
- 输入 GitHub 仓库 URL
- 选择版本规则

```

---

#### 3. common_patterns.md（推荐）

**用途**: 项目中常用的代码模式和最佳实践

**推荐大小**: 300-500 行

**标准模板**:
```markdown
# 常用代码模式

## 网络请求模式

### 使用 async/await（推荐）

```swift
// 定义 API Service
class UserService {
    static let shared = UserService()
    
    func fetchUserInfo(userId: Int) async throws -> User {
        let url = "\(APIConfig.baseURL)/users/\(userId)"
        let (data, _) = try await URLSession.shared.data(from: URL(string: url)!)
        return try JSONDecoder().decode(User.self, from: data)
    }
}

// 使用
Task {
    do {
        let user = try await UserService.shared.fetchUserInfo(userId: 123)
        updateUI(with: user)
    } catch {
        showError(error)
    }
}
```

### 使用 Combine

```swift
import Combine

class UserViewModel: ObservableObject {
    @Published var user: User?
    @Published var isLoading = false
    
    private var cancellables = Set<AnyCancellable>()
    
    func loadUser(userId: Int) {
        isLoading = true
        
        UserService.shared.fetchUserPublisher(userId: userId)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                self?.isLoading = false
                if case .failure(let error) = completion {
                    // 处理错误
                }
            } receiveValue: { [weak self] user in
                self?.user = user
            }
            .store(in: &cancellables)
    }
}
```

---

## UI 组件创建模式

### UIKit + SnapKit

```swift
class CustomView: UIView {
    // MARK: - UI Components
    
    private let titleLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 18, weight: .bold)
        label.textColor = .black
        return label
    }()
    
    private lazy var actionButton: UIButton = {
        let button = UIButton(type: .system)
        button.setTitle("确认", for: .normal)
        button.addTarget(self, action: #selector(handleAction), for: .touchUpInside)
        return button
    }()
    
    // MARK: - Initialization
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupUI()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - UI Setup
    
    private func setupUI() {
        addSubview(titleLabel)
        addSubview(actionButton)
        
        titleLabel.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(20)
            make.left.right.equalToSuperview().inset(16)
        }
        
        actionButton.snp.makeConstraints { make in
            make.top.equalTo(titleLabel.snp.bottom).offset(20)
            make.centerX.equalToSuperview()
            make.width.equalTo(120)
            make.height.equalTo(44)
        }
    }
    
    // MARK: - Actions
    
    @objc private func handleAction() {
        // 处理按钮点击
    }
}
```

### SwiftUI

```swift
struct UserProfileView: View {
    @StateObject private var viewModel = UserProfileViewModel()
    
    var body: some View {
        VStack(spacing: 20) {
            if viewModel.isLoading {
                ProgressView()
            } else if let user = viewModel.user {
                AsyncImage(url: URL(string: user.avatarURL)) { image in
                    image.resizable()
                } placeholder: {
                    Color.gray
                }
                .frame(width: 100, height: 100)
                .clipShape(Circle())
                
                Text(user.name)
                    .font(.title)
                
                Button("编辑") {
                    viewModel.editUser()
                }
            }
        }
        .task {
            await viewModel.loadUser()
        }
    }
}
```

---

## 数据处理模式

### JSON 解析（Codable）

```swift
// 定义模型
struct User: Codable {
    let id: Int
    let name: String
    let email: String
    let avatarURL: String?
    
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case email
        case avatarURL = "avatar_url"
    }
}

// 解析
let decoder = JSONDecoder()
decoder.keyDecodingStrategy = .convertFromSnakeCase
let user = try decoder.decode(User.self, from: data)

// 编码
let encoder = JSONEncoder()
encoder.keyEncodingStrategy = .convertToSnakeCase
let data = try encoder.encode(user)
```

### 本地存储（UserDefaults）

```swift
extension UserDefaults {
    private enum Keys {
        static let userToken = "userToken"
        static let isFirstLaunch = "isFirstLaunch"
    }
    
    var userToken: String? {
        get { string(forKey: Keys.userToken) }
        set { set(newValue, forKey: Keys.userToken) }
    }
    
    var isFirstLaunch: Bool {
        get { bool(forKey: Keys.isFirstLaunch) }
        set { set(newValue, forKey: Keys.isFirstLaunch) }
    }
}
```

### Keychain 存储（敏感数据）

```swift
import Security

class KeychainManager {
    static let shared = KeychainManager()
    
    func save(_ value: String, forKey key: String) -> Bool {
        guard let data = value.data(using: .utf8) else { return false }
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecValueData as String: data
        ]
        
        SecItemDelete(query as CFDictionary)
        return SecItemAdd(query as CFDictionary, nil) == errSecSuccess
    }
    
    func get(forKey key: String) -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        guard status == errSecSuccess,
              let data = result as? Data,
              let string = String(data: data, encoding: .utf8) else {
            return nil
        }
        
        return string
    }
}
```

---

## 错误处理模式

### 自定义错误类型

```swift
enum AppError: LocalizedError {
    case networkError(String)
    case dataParsingError
    case unauthorized
    case unknown
    
    var errorDescription: String? {
        switch self {
        case .networkError(let message):
            return "网络错误: \(message)"
        case .dataParsingError:
            return "数据解析失败"
        case .unauthorized:
            return "未授权，请重新登录"
        case .unknown:
            return "未知错误"
        }
    }
}
```

### 统一错误处理

```swift
extension UIViewController {
    func handleError(_ error: Error) {
        let message: String
        
        if let appError = error as? AppError {
            message = appError.errorDescription ?? "未知错误"
        } else {
            message = error.localizedDescription
        }
        
        showAlert(title: "错误", message: message)
    }
    
    private func showAlert(title: String, message: String) {
        let alert = UIAlertController(
            title: title,
            message: message,
            preferredStyle: .alert
        )
        alert.addAction(UIAlertAction(title: "确定", style: .default))
        present(alert, animated: true)
    }
}
```

---

## MVVM 架构模式

```swift
// Model
struct Product: Codable {
    let id: Int
    let name: String
    let price: Double
}

// ViewModel
class ProductListViewModel: ObservableObject {
    @Published var products: [Product] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private let service: ProductService
    
    init(service: ProductService = ProductService.shared) {
        self.service = service
    }
    
    func loadProducts() async {
        isLoading = true
        errorMessage = nil
        
        do {
            products = try await service.fetchProducts()
        } catch {
            errorMessage = error.localizedDescription
        }
        
        isLoading = false
    }
}

// View (SwiftUI)
struct ProductListView: View {
    @StateObject private var viewModel = ProductListViewModel()
    
    var body: some View {
        List(viewModel.products, id: \.id) { product in
            HStack {
                Text(product.name)
                Spacer()
                Text("$\(product.price, specifier: "%.2f")")
            }
        }
        .task {
            await viewModel.loadProducts()
        }
    }
}
```
```

---

#### 4. architecture.md（可选，复杂项目）

**用途**: 详细的架构设计说明

**推荐大小**: 200-400 行

**适用场景**:
- 使用复杂架构模式（VIPER、Clean Architecture）
- 有明确的分层设计
- 需要详细说明模块间通信

---

#### 5. api_guide.md（可选，API 密集型项目）

**用途**: API 使用指南和文档

**推荐大小**: 200-400 行

**适用场景**:
- RESTful API 较多
- 有复杂的认证流程
- 需要记录 API 端点和参数

---

## 构建流程

### 从头构建 Memories

当用户请求 `@serena-maintenance 从头构建项目 memories` 时：

**步骤 1: 评估项目规模**
1. 使用 `mcp_serena_list_dir` 查看项目结构
2. 统计源文件数量
3. 根据规模确定文件数量（1-5 个）

**步骤 2: 收集项目信息**
1. 读取 `Podfile` / `Package.swift` 了解依赖
2. 读取 `Info.plist` 了解基本配置
3. 查看主要源文件了解架构模式
4. 分析目录结构

**步骤 3: 优先创建 project_overview.md**
1. 项目基本信息
2. 技术栈概览（5-10 个核心库）
3. 简化的目录结构
4. 核心架构说明
5. 关键约定（如类前缀、基类等）

**步骤 4: 根据需要创建其他文件**

**创建 tech_stack.md** 当:
- 使用了 5+ 个第三方库
- 库的配置较复杂
- 有特定的使用模式

**创建 common_patterns.md** 当:
- 有统一的代码模式
- 网络请求、UI 创建有特定规范
- 有自定义的架构实现

**步骤 5: 验证和优化**
1. 确保每个文件内容完整
2. 检查文件大小（< 500 行）
3. 验证代码示例来自实际项目
4. 确保没有与 Cursor rules 重复

---

### 更新现有 Memories

**步骤 1: 评估变更**
1. 使用 `mcp_serena_list_memories` 查看现有文件
2. 确定需要更新的文件
3. 读取相关文件了解当前内容

**步骤 2: 收集新信息**
1. 从代码中提取实际示例
2. 询问用户具体变更
3. 检查新增的依赖或架构变化

**步骤 3: 更新内容**
1. 使用 `mcp_serena_write_memory` 更新
2. 保持原有结构
3. 确保代码示例可运行
4. 验证信息准确性

---

### 审计 Memories 质量

当用户请求审计时，检查以下方面：

**1. 内容质量检查**
- [ ] 信息是否准确和最新
- [ ] 是否有过时的内容
- [ ] 代码示例是否来自实际项目
- [ ] 代码示例是否可运行
- [ ] 是否有重复信息

**2. 结构组织检查**
- [ ] 文件数量是否合理（不超过 5 个）
- [ ] 每个文件职责是否清晰
- [ ] 文件大小是否适中（< 500 行）
- [ ] 标题层级是否清晰
- [ ] 是否有过度碎片化

**3. 与 Cursor Rules 的关系**
- [ ] 是否有应该在 Cursor rules 的内容
- [ ] 是否有与 Cursor rules 重复的内容
- [ ] 是否有通用规范混入项目特定信息

**4. 可用性检查**
- [ ] 文件名是否描述性强
- [ ] 是否容易找到需要的信息
- [ ] 代码示例是否实用
- [ ] 说明是否清晰

---

### 精简 Memories

当 memories 内容过多或冗余时：

**步骤 1: 识别问题**
- 文件数量过多（> 5 个）
- 单个文件过大（> 500 行）
- 有重复内容
- 有通用内容（应该在 Cursor rules）

**步骤 2: 合并策略**
- 将相关小文件合并（如 api_guide 合并到 tech_stack）
- 提取通用内容到 Cursor rules
- 删除过时内容
- 精简冗长的解释

**步骤 3: 重组**
- 按照标准模板重新组织
- 确保符合推荐的文件数量
- 保持关键信息不丢失
- 验证代码示例仍然有效

---

## 更新触发场景

### 必须更新的情况
- ✅ 项目结构发生重大变化
- ✅ 添加或删除了重要的第三方库
- ✅ 架构模式发生变化
- ✅ API 基础配置变更

### 建议更新的情况
- ⚠️ 发现了新的最佳实践
- ⚠️ 解决了重要的技术问题
- ⚠️ 常用代码模式有变化
- ⚠️ 定期维护（如季度审计）

### 不需要更新的情况
- ❌ 小的代码修改
- ❌ 临时的调试信息
- ❌ 单个 bug 修复
- ❌ UI 样式微调

---

## 质量标准

### 内容要求
- ✅ 使用 Markdown 格式
- ✅ 清晰的标题层级（# ## ###）
- ✅ 包含实用的代码示例
- ✅ 代码示例来自实际项目，可运行
- ✅ 突出重要信息（使用粗体、引用等）
- ❌ 避免与 Cursor rules 重复
- ❌ 避免记录通用知识（Swift 语法等）
- ❌ 避免过度详细的注释

### 结构要求
- ✅ 每个文件有清晰的用途
- ✅ 章节组织合理
- ✅ 使用代码块标注语言
- ✅ 使用列表、表格提高可读性

### 大小控制
- ✅ 单个文件 < 500 行
- ✅ 总文件数 ≤ 5 个
- ✅ `project_overview.md` < 200 行

---

## 常见维护命令

### 完整重建
```
@serena-maintenance 从头构建项目 memories
```
AI 将：分析项目 → 创建标准文件 → 填充内容 → 验证质量

### 更新特定文件
```
@serena-maintenance 更新 tech_stack.md，我添加了 Alamofire
```
AI 将：读取文件 → 添加新库信息 → 更新文件

### 质量审计
```
@serena-maintenance 审计现有 memories 的质量
```
AI 将：检查所有 memories → 识别问题 → 提供改进建议

### 精简优化
```
@serena-maintenance 精简 memories，删除冗余内容
```
AI 将：分析内容 → 合并相关文件 → 删除冗余 → 重新组织

### 检查过时内容
```
@serena-maintenance 检查 memories 是否过时
```
AI 将：对比代码 → 识别过时信息 → 更新内容

---

## 最佳实践

### DO
- ✅ 定期审计 memories（建议每季度或重大更新后）
- ✅ 保持文件数量精简（1-5 个）
- ✅ 使用标准模板确保一致性
- ✅ 代码示例来自实际项目
- ✅ 及时更新重要变更

### DON'T
- ❌ 不要创建过多碎片化文件
- ❌ 不要在 memory 中记录通用知识
- ❌ 不要与 Cursor rules 重复
- ❌ 不要让单个文件过大（> 500 行）
- ❌ 不要记录临时信息

---

**重要提醒**: 本规则仅在用户明确请求时使用。日常开发使用 `01-serena-workflow.mdc` 规则。
